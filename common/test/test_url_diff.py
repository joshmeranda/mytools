import pathlib
import os
import pytest
from http.server import BaseHTTPRequestHandler, HTTPServer
from http.client import HTTPConnection, HTTPException
import uuid
import socket
import subprocess
import base64
import _thread as thread
import time


_URL_DIFF_TIMEOUT: int = 5
_URL_DIFF_PATH: str = os.path.abspath("common/url-diff.bash")

_ENV_URL_DIFF_CACHE_DIR = "CACHE_DIR"

_url_base64: dict[str, str] = {}
_bad_url_example = "https://host/path"


def register_url(url: str):
	_url_base64[url] = systemBase64Encode(url)


def systemBase64Encode(s: str) -> str:
	'''systemBase64Encode uses the base64 binary on the system to generate the base64 encoding.
	
	This removes any incongruencies between the base 64 encoding generated by python vs what is generated by the
	underlying script. Because this launches child processes, minimize the use of this func.
	'''
	proc = subprocess.run(
		args=["bash", "-c", f"echo '{s}' | base64"],
		capture_output=True,
		timeout=1,
	)

	return proc.stdout.strip().decode()


@pytest.fixture(scope="module")
def free_port() -> str:
	sock = socket.socket()
	sock.bind(("", 0))
	
	port = sock.getsockname()[1]
	
	sock.close()
	
	return port


class Handler(BaseHTTPRequestHandler):
	def do_GET(self):
		match self.path:
			case "/health":
				self.send_response(200)

				self.send_header("Content-Length", 2)
				self.end_headers()

				self.wfile.write("ok".encode("ascii"))
			case "/static":
				self.send_response(200)

				self.send_header("Content-Length", 6)
				self.end_headers()

				self.wfile.write("static".encode("ascii"))
			case "/dynamic":
				id = uuid.uuid1().bytes

				self.send_response(200)

				self.send_header("Content-Length", len(id))
				self.end_headers()

				self.wfile.write(id)


@pytest.fixture(scope="module")
def setup_server(free_port: str) -> tuple[str, str]:
	s = HTTPServer(("", free_port), Handler)
	thread.start_new_thread(s.serve_forever, ())

	addr = f"http://{s.server_address[0]}:{s.server_address[1]}"

	register_url(addr + "/health")
	register_url(addr + "/static")
	register_url(addr + "/dynamic")
	register_url(_bad_url_example)

	yield s.server_address

	s.shutdown()


@pytest.fixture
def server(setup_server: tuple[str, str]) -> tuple[str, str]:
	for i in range(10):
		try:
			conn = HTTPConnection(setup_server[0], int(setup_server[1]))
			conn.request("GET", "/health")

			response = conn.getresponse()

			if response.status == 200:
				return setup_server
		except HTTPException as err:
			time.sleep(1)
	
	
	raise Exception("could not contact server in time")


@pytest.fixture(scope="function")
def cache_path(server: tuple[str, str], tmp_path: pathlib.Path) -> pathlib.Path:
	url = f'http://{server[0]}:{server[1]}/static'
	url64 = _url_base64[url]

	(tmp_path / url64).mkdir()
	(tmp_path / url64 / "data").open("w").write("static")
	(tmp_path / url64 / "wget").open("w").write("--quiet")

	return tmp_path


class TestUrlDiffAdd:
	def test_add_new(self, tmp_path: pathlib.Path, server: tuple[str, int]):
		url = f'http://{server[0]}:{server[1]}/static'
		url64 = _url_base64[url]

		proc = subprocess.run(
			args=[_URL_DIFF_PATH, "add", url],
			env={
				_ENV_URL_DIFF_CACHE_DIR: str(tmp_path),
			},
			capture_output=True,
			timeout=_URL_DIFF_TIMEOUT,
		)

		assert proc.returncode == 0
		assert (tmp_path / url64).exists()
		assert (tmp_path / url64 / "data").exists()
		assert not (tmp_path / url64 / "wget").exists()
		
		with open(tmp_path / url64 / "data") as f:
			assert f.read() == "static"

	def test_add_with_wget_options(self, tmp_path: pathlib.Path, server: tuple[str, int]):
		pytest.skip("does not yet work properlly")
		url = f'http://{server[0]}:{server[1]}/static'
		url64 = _url_base64[url]

		proc = subprocess.run(
			args=[_URL_DIFF_PATH, "add", url, "--header=\"foo: bar\"",],
			env={
				_ENV_URL_DIFF_CACHE_DIR: str(tmp_path),
			},
			capture_output=True,
			timeout=_URL_DIFF_TIMEOUT,
		)

		assert proc.returncode == 0
		assert (tmp_path / url64).exists()
		assert (tmp_path / url64 / "data").exists()
		assert (tmp_path / url64 / "wget").exists()

		with open(tmp_path / url64 / "data") as f:
			assert f.read() == "static"

		with open(tmp_path / url64 / "wget") as f:
			assert f.read() == "--header=\\'foo: bar\\'\n"

	def test_add_with_existing(self, tmp_path: pathlib.Path, server: tuple[str, int]):
		url = f'http://{server[0]}:{server[1]}/static'
		url64 = _url_base64[url]

		(tmp_path / url64).mkdir()

		proc = subprocess.run(
			args=[_URL_DIFF_PATH, "add", url],
			env={
				_ENV_URL_DIFF_CACHE_DIR: str(tmp_path),
			},
			capture_output=True,
			timeout=_URL_DIFF_TIMEOUT,
		)

		assert proc.returncode == 1
		assert (tmp_path / url64).exists()
		assert not (tmp_path / url64 / "data").exists()
		assert not (tmp_path / url64 / "wget").exists()
		assert proc.stdout == f"Error: cache for '{url}' already exists\n".encode()

	def test_add_with_bad_url(self, tmp_path: pathlib.Path):
		url = _bad_url_example
		url64 = _url_base64[url]

		proc = subprocess.run(
			args=[_URL_DIFF_PATH, "add", url],
			env={
				_ENV_URL_DIFF_CACHE_DIR: str(tmp_path),
			},
			capture_output=True,
			timeout=_URL_DIFF_TIMEOUT,
		)

		assert proc.returncode == 1
		assert not (tmp_path / url64).exists()
		assert not (tmp_path / url64 / "data").exists()
		assert not (tmp_path / url64 / "wget").exists()
		assert proc.stdout == f"Error: failed to fetch from url '{url}'\n".encode()

	def test_add_with_no_url(self, tmp_path: pathlib.Path):
		proc = subprocess.run(
			args=[_URL_DIFF_PATH, "add"],
			env={
				_ENV_URL_DIFF_CACHE_DIR: str(tmp_path),
			},
			capture_output=True,
			timeout=_URL_DIFF_TIMEOUT,
		)

		assert proc.returncode == 1
		assert proc.stdout == f"Error: expected url but found none\n".encode()


class TestUrlDiffRemove:
	def test_remove_existing(self, cache_path: pathlib.Path, server: tuple[str, int]):
		url = f'http://{server[0]}:{server[1]}/static'
		url64 = _url_base64[url]

		proc = subprocess.run(
			args=[_URL_DIFF_PATH, "remove", url],
			env={
				_ENV_URL_DIFF_CACHE_DIR: str(cache_path),
			},
			capture_output=True,
			timeout=_URL_DIFF_TIMEOUT,
		)

		assert proc.returncode == 0
		assert not (cache_path / url64).exists()
		assert not (cache_path / url64 / "data").exists()

	def test_remove_non_existing(self, cache_path: pathlib.Path, server: tuple[str, str]):
		url64 = _url_base64[_bad_url_example]

		proc = subprocess.run(
			args=[_URL_DIFF_PATH, "remove", _bad_url_example],
			env={
				_ENV_URL_DIFF_CACHE_DIR: str(cache_path),
			},
			capture_output=True,
			timeout=_URL_DIFF_TIMEOUT,
		)

		assert proc.returncode == 1
		assert not (cache_path / url64).exists()
		assert not (cache_path / url64 / "data").exists()

	def test_remove_with_no_url(self):
		proc = subprocess.run(
			args=[_URL_DIFF_PATH, "remove"],
			env={
				_ENV_URL_DIFF_CACHE_DIR: str(cache_path),
			},
			capture_output=True,
			timeout=_URL_DIFF_TIMEOUT,
		)

		assert proc.returncode == 1
		assert proc.stdout == "Error: expected url but found none\n".encode()


class TestUrlDiffList:
	pass


class TestUrlDiffCheck:
	pass